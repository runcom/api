
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.openshift.api.machineconfiguration.v1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";
import "k8s.io/kubelet/config/v1beta1/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1";

// ContainerRuntimeConfig describes a customized Container Runtime configuration.
message ContainerRuntimeConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ContainerRuntimeConfigSpec spec = 2;

  optional ContainerRuntimeConfigStatus status = 3;
}

// ContainerRuntimeConfigCondition defines the state of the ContainerRuntimeConfig
message ContainerRuntimeConfigCondition {
  // type specifies the state of the operator's reconciliation functionality.
  optional string type = 1;

  // status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // lastTransitionTime is the time of the last update to the current status object.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // reason is the reason for the condition's last transition.  Reasons are CamelCase
  optional string reason = 4;

  // message provides additional information about the current condition.
  // This is only to be consumed by humans.
  optional string message = 5;
}

// ContainerRuntimeConfigList is a list of ContainerRuntimeConfig resources
message ContainerRuntimeConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ContainerRuntimeConfig items = 2;
}

// ContainerRuntimeConfigSpec defines the desired state of ContainerRuntimeConfig
message ContainerRuntimeConfigSpec {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector machineConfigPoolSelector = 1;

  optional ContainerRuntimeConfiguration containerRuntimeConfig = 2;
}

// ContainerRuntimeConfigStatus defines the observed state of a ContainerRuntimeConfig
message ContainerRuntimeConfigStatus {
  // The generation observed by the controller.
  optional int64 observedGeneration = 1;

  // Represents the latest available observations of current state.
  repeated ContainerRuntimeConfigCondition conditions = 2;
}

// ContainerRuntimeConfiguration defines the tuneables of the container runtime
message ContainerRuntimeConfiguration {
  optional int64 pidsLimit = 1;

  optional string logLevel = 2;

  optional k8s.io.apimachinery.pkg.api.resource.Quantity logSizeMax = 3;

  optional k8s.io.apimachinery.pkg.api.resource.Quantity overlaySize = 4;
}

// ControllerConfig describes configuration for MachineConfigController.
// This is currently only used to drive the machineconfigs generated by the TemplateController.
message ControllerConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ControllerConfigSpec spec = 2;

  optional ControllerConfigStatus status = 3;
}

// ControllerConfigList is a list of ControllerConfig resources
message ControllerConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ControllerConfig items = 2;
}

// ControllerConfigSpec is the spec for ControllerConfig resource.
message ControllerConfigSpec {
  optional string clusterDNSIP = 1;

  optional string cloudProviderConfig = 2;

  // The openshift platform, e.g. "libvirt", "openstack", "aws", or "none"
  optional string platform = 3;

  optional string etcdDiscoveryDomain = 4;

  // CAs
  optional bytes etcdCAData = 5;

  optional bytes etcdMetricCAData = 6;

  optional bytes rootCAData = 7;

  // PullSecret is the default pull secret that needs to be installed
  // on all machines.
  optional k8s.io.api.core.v1.ObjectReference pullSecret = 8;

  // Images is map of images that are used by the controller.
  map<string, string> images = 9;

  // Sourced from configmap/machine-config-osimageurl
  optional string osImageURL = 10;
}

// ControllerConfigStatus is the status for ControllerConfig
message ControllerConfigStatus {
  // The generation observed by the controller.
  optional int64 observedGeneration = 1;

  // Represents the latest available observations of current state.
  repeated ControllerConfigStatusCondition conditions = 2;
}

// ControllerConfigStatusCondition contains condition information for ControllerConfigStatus
message ControllerConfigStatusCondition {
  // type specifies the state of the operator's reconciliation functionality.
  optional string type = 1;

  // status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // lastTransitionTime is the time of the last update to the current status object.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // reason is the reason for the condition's last transition.  Reasons are CamelCase
  optional string reason = 4;

  // message provides additional information about the current condition.
  // This is only to be consumed by humans.
  optional string message = 5;
}

// KubeletConfig describes a customized Kubelet configuration.
message KubeletConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional KubeletConfigSpec spec = 2;

  optional KubeletConfigStatus status = 3;
}

// KubeletConfigCondition defines the state of the KubeletConfig
message KubeletConfigCondition {
  // type specifies the state of the operator's reconciliation functionality.
  optional string type = 1;

  // status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // lastTransitionTime is the time of the last update to the current status object.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // reason is the reason for the condition's last transition.  Reasons are CamelCase
  optional string reason = 4;

  // message provides additional information about the current condition.
  // This is only to be consumed by humans.
  optional string message = 5;
}

// KubeletConfigList is a list of KubeletConfig resources
message KubeletConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KubeletConfig items = 2;
}

// KubeletConfigSpec defines the desired state of KubeletConfig
message KubeletConfigSpec {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector machineConfigPoolSelector = 1;

  optional k8s.io.kubelet.config.v1beta1.KubeletConfiguration kubeletConfig = 2;
}

// KubeletConfigStatus defines the observed state of a KubeletConfig
message KubeletConfigStatus {
  // The generation observed by the controller.
  optional int64 observedGeneration = 1;

  // Represents the latest available observations of current state.
  repeated KubeletConfigCondition conditions = 2;
}

// MCOConfig describes configuration for MachineConfigOperator.
message MCOConfig {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional MCOConfigSpec spec = 2;
}

// MCOConfigList is a list of MCOConfig resources
message MCOConfigList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated MCOConfig items = 2;
}

// MCOConfigSpec is the spec for MCOConfig resource.
message MCOConfigSpec {
}

// MachineConfigPool describes a pool of MachineConfigs.
message MachineConfigPool {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional MachineConfigPoolSpec spec = 2;

  optional MachineConfigPoolStatus status = 3;
}

// MachineConfigPoolCondition contains condition information for an MachineConfigPool.
message MachineConfigPoolCondition {
  // Type of the condition, currently ('Done', 'Updating', 'Failed').
  optional string type = 1;

  // Status of the condition, one of ('True', 'False', 'Unknown').
  optional string status = 2;

  // LastTransitionTime is the timestamp corresponding to the last status
  // change of this condition.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // Reason is a brief machine readable explanation for the condition's last
  // transition.
  optional string reason = 4;

  // Message is a human readable description of the details of the last
  // transition, complementing reason.
  optional string message = 5;
}

// MachineConfigPoolList is a list of MachineConfigPool resources
message MachineConfigPoolList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated MachineConfigPool items = 2;
}

// MachineConfigPoolSpec is the spec for MachineConfigPool resource.
message MachineConfigPoolSpec {
  // Label selector for MachineConfigs.
  // Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ on how label and selectors work.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector machineConfigSelector = 1;

  // Node selector for Machines
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeSelector = 2;

  // If true, changes to this machine config pool should be stopped.
  // This includes generating new desiredMachineConfig and update of machines.
  optional bool paused = 3;

  // MaxUnavailable specifies the percentage or constant number of machines that can be updating at any given time.
  // default is 1.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 4;
}

// MachineConfigPoolStatus is the status for MachineConfigPool resource.
message MachineConfigPoolStatus {
  // The generation observed by the controller.
  optional int64 observedGeneration = 1;

  // The current MachineConfig object for the machine config pool.
  optional MachineConfigPoolStatusConfiguration configuration = 2;

  // Total number of machines in the machine config pool.
  optional int32 machineCount = 3;

  // Total number of machines targeted by the pool that have the CurrentMachineConfig as their config.
  optional int32 updatedMachineCount = 4;

  // Total number of ready machines targeted by the pool.
  optional int32 readyMachineCount = 5;

  // Total number of unavailable (non-ready) machines targeted by the pool.
  // A node is marked unavailable if it is in updating state or NodeReady condition is false.
  optional int32 unavailableMachineCount = 6;

  // Total number of machines marked degraded (or unreconcilable).
  // A node is marked degraded if applying a configuration failed..
  optional int32 degradedMachineCount = 7;

  // Represents the latest available observations of current state.
  repeated MachineConfigPoolCondition conditions = 8;
}

// MachineConfigPoolStatusConfiguration stores the current configuration for the pool, and
// optionally also stores the list of machineconfig objects used to generate the configuration.
message MachineConfigPoolStatusConfiguration {
  optional k8s.io.api.core.v1.ObjectReference objectReference = 1;

  // source is the list of machineconfigs that were used to generate the single machineconfig object specified in `content`.
  // +optional
  repeated k8s.io.api.core.v1.ObjectReference source = 2;
}

message KubeletAnonymousAuthentication {
  // enabled allows anonymous requests to the kubelet server.
  // Requests that are not rejected by another authentication method are treated as anonymous requests.
  // Anonymous requests have a username of system:anonymous, and a group name of system:unauthenticated.
  // +optional
  optional bool enabled = 1;
}

message KubeletAuthentication {
  // x509 contains settings related to x509 client certificate authentication
  // +optional
  optional k8s.io.kubelet.config.v1beta1.KubeletX509Authentication x509 = 1;

  // webhook contains settings related to webhook bearer token authentication
  // +optional
  optional k8s.io.kubelet.config.v1beta1.KubeletWebhookAuthentication webhook = 2;

  // anonymous contains settings related to anonymous authentication
  // +optional
  optional k8s.io.kubelet.config.v1beta1.KubeletAnonymousAuthentication anonymous = 3;
}

message KubeletAuthorization {
  // mode is the authorization mode to apply to requests to the kubelet server.
  // Valid values are AlwaysAllow and Webhook.
  // Webhook mode uses the SubjectAccessReview API to determine authorization.
  // +optional
  optional string mode = 1;

  // webhook contains settings related to Webhook authorization.
  // +optional
  optional k8s.io.kubelet.config.v1beta1.KubeletWebhookAuthorization webhook = 2;
}

// KubeletConfiguration contains the configuration for the Kubelet
message KubeletConfiguration {
  // staticPodPath is the path to the directory containing local (static) pods to
  // run, or the path to a single static pod file.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // the set of static pods specified at the new path may be different than the
  // ones the Kubelet initially started with, and this may disrupt your node.
  // Default: ""
  // +optional
  optional string staticPodPath = 1;

  // syncFrequency is the max period between synchronizing running
  // containers and config.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // shortening this duration may have a negative performance impact, especially
  // as the number of Pods on the node increases. Alternatively, increasing this
  // duration will result in longer refresh times for ConfigMaps and Secrets.
  // Default: "1m"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration syncFrequency = 2;

  // fileCheckFrequency is the duration between checking config files for
  // new data
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // shortening the duration will cause the Kubelet to reload local Static Pod
  // configurations more frequently, which may have a negative performance impact.
  // Default: "20s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration fileCheckFrequency = 3;

  // httpCheckFrequency is the duration between checking http for new data
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // shortening the duration will cause the Kubelet to poll staticPodURL more
  // frequently, which may have a negative performance impact.
  // Default: "20s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration httpCheckFrequency = 4;

  // staticPodURL is the URL for accessing static pods to run
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // the set of static pods specified at the new URL may be different than the
  // ones the Kubelet initially started with, and this may disrupt your node.
  // Default: ""
  // +optional
  optional string staticPodURL = 5;

  // staticPodURLHeader is a map of slices with HTTP headers to use when accessing the podURL
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt the ability to read the latest set of static pods from StaticPodURL.
  // Default: nil
  // +optional
  map<string, string> staticPodURLHeader = 6;

  // address is the IP address for the Kubelet to serve on (set to 0.0.0.0
  // for all interfaces).
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: "0.0.0.0"
  // +optional
  optional string address = 7;

  // port is the port for the Kubelet to serve on.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: 10250
  // +optional
  optional int32 port = 8;

  // readOnlyPort is the read-only port for the Kubelet to serve on with
  // no authentication/authorization.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: 0 (disabled)
  // +optional
  optional int32 readOnlyPort = 9;

  // tlsCertFile is the file containing x509 Certificate for HTTPS. (CA cert,
  // if any, concatenated after server cert). If tlsCertFile and
  // tlsPrivateKeyFile are not provided, a self-signed certificate
  // and key are generated for the public address and saved to the directory
  // passed to the Kubelet's --cert-dir flag.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: ""
  // +optional
  optional string tlsCertFile = 10;

  // tlsPrivateKeyFile is the file containing x509 private key matching tlsCertFile
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: ""
  // +optional
  optional string tlsPrivateKeyFile = 11;

  // TLSCipherSuites is the list of allowed cipher suites for the server.
  // Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: nil
  // +optional
  repeated string tlsCipherSuites = 12;

  // TLSMinVersion is the minimum TLS version supported.
  // Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: ""
  // +optional
  optional string tlsMinVersion = 13;

  // rotateCertificates enables client certificate rotation. The Kubelet will request a
  // new certificate from the certificates.k8s.io API. This requires an approver to approve the
  // certificate signing requests. The RotateKubeletClientCertificate feature
  // must be enabled.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // disabling it may disrupt the Kubelet's ability to authenticate with the API server
  // after the current certificate expires.
  // Default: false
  // +optional
  optional bool rotateCertificates = 14;

  // serverTLSBootstrap enables server certificate bootstrap. Instead of self
  // signing a serving certificate, the Kubelet will request a certificate from
  // the certificates.k8s.io API. This requires an approver to approve the
  // certificate signing requests. The RotateKubeletServerCertificate feature
  // must be enabled.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // disabling it will stop the renewal of Kubelet server certificates, which can
  // disrupt components that interact with the Kubelet server in the long term,
  // due to certificate expiration.
  // Default: false
  // +optional
  optional bool serverTLSBootstrap = 15;

  // authentication specifies how requests to the Kubelet's server are authenticated
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Defaults:
  //   anonymous:
  //     enabled: false
  //   webhook:
  //     enabled: true
  //     cacheTTL: "2m"
  // +optional
  optional k8s.io.kubelet.config.v1beta1.KubeletAuthentication authentication = 16;

  // authorization specifies how requests to the Kubelet's server are authorized
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Defaults:
  //   mode: Webhook
  //   webhook:
  //     cacheAuthorizedTTL: "5m"
  //     cacheUnauthorizedTTL: "30s"
  // +optional
  optional k8s.io.kubelet.config.v1beta1.KubeletAuthorization authorization = 17;

  // registryPullQPS is the limit of registry pulls per second.
  // Set to 0 for no limit.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact scalability by changing the amount of traffic produced
  // by image pulls.
  // Default: 5
  // +optional
  optional int32 registryPullQPS = 18;

  // registryBurst is the maximum size of bursty pulls, temporarily allows
  // pulls to burst to this number, while still not exceeding registryPullQPS.
  // Only used if registryPullQPS > 0.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact scalability by changing the amount of traffic produced
  // by image pulls.
  // Default: 10
  // +optional
  optional int32 registryBurst = 19;

  // eventRecordQPS is the maximum event creations per second. If 0, there
  // is no limit enforced.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact scalability by changing the amount of traffic produced by
  // event creations.
  // Default: 5
  // +optional
  optional int32 eventRecordQPS = 20;

  // eventBurst is the maximum size of a burst of event creations, temporarily
  // allows event creations to burst to this number, while still not exceeding
  // eventRecordQPS. Only used if eventRecordQPS > 0.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact scalability by changing the amount of traffic produced by
  // event creations.
  // Default: 10
  // +optional
  optional int32 eventBurst = 21;

  // enableDebuggingHandlers enables server endpoints for log access
  // and local running of containers and commands, including the exec,
  // attach, logs, and portforward features.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // disabling it may disrupt components that interact with the Kubelet server.
  // Default: true
  // +optional
  optional bool enableDebuggingHandlers = 22;

  // enableContentionProfiling enables lock contention profiling, if enableDebuggingHandlers is true.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // enabling it may carry a performance impact.
  // Default: false
  // +optional
  optional bool enableContentionProfiling = 23;

  // healthzPort is the port of the localhost healthz endpoint (set to 0 to disable)
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that monitor Kubelet health.
  // Default: 10248
  // +optional
  optional int32 healthzPort = 24;

  // healthzBindAddress is the IP address for the healthz server to serve on
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that monitor Kubelet health.
  // Default: "127.0.0.1"
  // +optional
  optional string healthzBindAddress = 25;

  // oomScoreAdj is The oom-score-adj value for kubelet process. Values
  // must be within the range [-1000, 1000].
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact the stability of nodes under memory pressure.
  // Default: -999
  // +optional
  optional int32 oomScoreAdj = 26;

  // clusterDomain is the DNS domain for this cluster. If set, kubelet will
  // configure all containers to search this domain in addition to the
  // host's search domains.
  // Dynamic Kubelet Config (beta): Dynamically updating this field is not recommended,
  // as it should be kept in sync with the rest of the cluster.
  // Default: ""
  // +optional
  optional string clusterDomain = 27;

  // clusterDNS is a list of IP addresses for the cluster DNS server. If set,
  // kubelet will configure all containers to use this for DNS resolution
  // instead of the host's DNS servers.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // changes will only take effect on Pods created after the update. Draining
  // the node is recommended before changing this field.
  // Default: nil
  // +optional
  repeated string clusterDNS = 28;

  // streamingConnectionIdleTimeout is the maximum time a streaming connection
  // can be idle before the connection is automatically closed.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact components that rely on infrequent updates over streaming
  // connections to the Kubelet server.
  // Default: "4h"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration streamingConnectionIdleTimeout = 29;

  // nodeStatusUpdateFrequency is the frequency that kubelet computes node
  // status. If node lease feature is not enabled, it is also the frequency that
  // kubelet posts node status to master.
  // Note: When node lease feature is not enabled, be cautious when changing the
  // constant, it must work with nodeMonitorGracePeriod in nodecontroller.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact node scalability, and also that the node controller's
  // nodeMonitorGracePeriod must be set to N*NodeStatusUpdateFrequency,
  // where N is the number of retries before the node controller marks
  // the node unhealthy.
  // Default: "10s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration nodeStatusUpdateFrequency = 30;

  // nodeStatusReportFrequency is the frequency that kubelet posts node
  // status to master if node status does not change. Kubelet will ignore this
  // frequency and post node status immediately if any change is detected. It is
  // only used when node lease feature is enabled. nodeStatusReportFrequency's
  // default value is 1m. But if nodeStatusUpdateFrequency is set explicitly,
  // nodeStatusReportFrequency's default value will be set to
  // nodeStatusUpdateFrequency for backward compatibility.
  // Default: "1m"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration nodeStatusReportFrequency = 31;

  // nodeLeaseDurationSeconds is the duration the Kubelet will set on its corresponding Lease,
  // when the NodeLease feature is enabled. This feature provides an indicator of node
  // health by having the Kublet create and periodically renew a lease, named after the node,
  // in the kube-node-lease namespace. If the lease expires, the node can be considered unhealthy.
  // The lease is currently renewed every 10s, per KEP-0009. In the future, the lease renewal interval
  // may be set based on the lease duration.
  // Requires the NodeLease feature gate to be enabled.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // decreasing the duration may reduce tolerance for issues that temporarily prevent
  // the Kubelet from renewing the lease (e.g. a short-lived network issue).
  // Default: 40
  // +optional
  optional int32 nodeLeaseDurationSeconds = 32;

  // imageMinimumGCAge is the minimum age for an unused image before it is
  // garbage collected.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may trigger or delay garbage collection, and may change the image overhead
  // on the node.
  // Default: "2m"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration imageMinimumGCAge = 33;

  // imageGCHighThresholdPercent is the percent of disk usage after which
  // image garbage collection is always run. The percent is calculated as
  // this field value out of 100.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may trigger or delay garbage collection, and may change the image overhead
  // on the node.
  // Default: 85
  // +optional
  optional int32 imageGCHighThresholdPercent = 34;

  // imageGCLowThresholdPercent is the percent of disk usage before which
  // image garbage collection is never run. Lowest disk usage to garbage
  // collect to. The percent is calculated as this field value out of 100.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may trigger or delay garbage collection, and may change the image overhead
  // on the node.
  // Default: 80
  // +optional
  optional int32 imageGCLowThresholdPercent = 35;

  // How frequently to calculate and cache volume disk usage for all pods
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // shortening the period may carry a performance impact.
  // Default: "1m"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration volumeStatsAggPeriod = 36;

  // kubeletCgroups is the absolute name of cgroups to isolate the kubelet in
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: ""
  // +optional
  optional string kubeletCgroups = 37;

  // systemCgroups is absolute name of cgroups in which to place
  // all non-kernel processes that are not already in a container. Empty
  // for no container. Rolling back the flag requires a reboot.
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: ""
  // +optional
  optional string systemCgroups = 38;

  // cgroupRoot is the root cgroup to use for pods. This is handled by the
  // container runtime on a best effort basis.
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: ""
  // +optional
  optional string cgroupRoot = 39;

  // Enable QoS based Cgroup hierarchy: top level cgroups for QoS Classes
  // And all Burstable and BestEffort pods are brought up under their
  // specific top level QoS cgroup.
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: true
  // +optional
  optional bool cgroupsPerQOS = 40;

  // driver that the kubelet uses to manipulate cgroups on the host (cgroupfs or systemd)
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: "cgroupfs"
  // +optional
  optional string cgroupDriver = 41;

  // CPUManagerPolicy is the name of the policy to use.
  // Requires the CPUManager feature gate to be enabled.
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: "none"
  // +optional
  optional string cpuManagerPolicy = 42;

  // CPU Manager reconciliation period.
  // Requires the CPUManager feature gate to be enabled.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // shortening the period may carry a performance impact.
  // Default: "10s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration cpuManagerReconcilePeriod = 43;

  // qosReserved is a set of resource name to percentage pairs that specify
  // the minimum percentage of a resource reserved for exclusive use by the
  // guaranteed QoS tier.
  // Currently supported resources: "memory"
  // Requires the QOSReserved feature gate to be enabled.
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: nil
  // +optional
  map<string, string> qosReserved = 44;

  // runtimeRequestTimeout is the timeout for all runtime requests except long running
  // requests - pull, logs, exec and attach.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may disrupt components that interact with the Kubelet server.
  // Default: "2m"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration runtimeRequestTimeout = 45;

  // hairpinMode specifies how the Kubelet should configure the container
  // bridge for hairpin packets.
  // Setting this flag allows endpoints in a Service to loadbalance back to
  // themselves if they should try to access their own Service. Values:
  //   "promiscuous-bridge": make the container bridge promiscuous.
  //   "hairpin-veth":       set the hairpin flag on container veth interfaces.
  //   "none":               do nothing.
  // Generally, one must set --hairpin-mode=hairpin-veth to achieve hairpin NAT,
  // because promiscuous-bridge assumes the existence of a container bridge named cbr0.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may require a node reboot, depending on the network plugin.
  // Default: "promiscuous-bridge"
  // +optional
  optional string hairpinMode = 46;

  // maxPods is the number of pods that can run on this Kubelet.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // changes may cause Pods to fail admission on Kubelet restart, and may change
  // the value reported in Node.Status.Capacity[v1.ResourcePods], thus affecting
  // future scheduling decisions. Increasing this value may also decrease performance,
  // as more Pods can be packed into a single node.
  // Default: 110
  // +optional
  optional int32 maxPods = 47;

  // The CIDR to use for pod IP addresses, only used in standalone mode.
  // In cluster mode, this is obtained from the master.
  // Dynamic Kubelet Config (beta): This field should always be set to the empty default.
  // It should only set for standalone Kubelets, which cannot use Dynamic Kubelet Config.
  // Default: ""
  // +optional
  optional string podCIDR = 48;

  // PodPidsLimit is the maximum number of pids in any pod.
  // Requires the SupportPodPidsLimit feature gate to be enabled.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // lowering it may prevent container processes from forking after the change.
  // Default: -1
  // +optional
  optional int64 podPidsLimit = 49;

  // ResolverConfig is the resolver configuration file used as the basis
  // for the container DNS resolution configuration.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // changes will only take effect on Pods created after the update. Draining
  // the node is recommended before changing this field.
  // Default: "/etc/resolv.conf"
  // +optional
  optional string resolvConf = 50;

  // cpuCFSQuota enables CPU CFS quota enforcement for containers that
  // specify CPU limits.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // disabling it may reduce node stability.
  // Default: true
  // +optional
  optional bool cpuCFSQuota = 51;

  // CPUCFSQuotaPeriod is the CPU CFS quota period value, cpu.cfs_period_us.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // limits set for containers will result in different cpu.cfs_quota settings. This
  // will trigger container restarts on the node being reconfigured.
  // Default: "100ms"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration cpuCFSQuotaPeriod = 52;

  // maxOpenFiles is Number of files that can be opened by Kubelet process.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact the ability of the Kubelet to interact with the node's filesystem.
  // Default: 1000000
  // +optional
  optional int64 maxOpenFiles = 53;

  // contentType is contentType of requests sent to apiserver.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact the ability for the Kubelet to communicate with the API server.
  // If the Kubelet loses contact with the API server due to a change to this field,
  // the change cannot be reverted via dynamic Kubelet config.
  // Default: "application/vnd.kubernetes.protobuf"
  // +optional
  optional string contentType = 54;

  // kubeAPIQPS is the QPS to use while talking with kubernetes apiserver
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact scalability by changing the amount of traffic the Kubelet
  // sends to the API server.
  // Default: 5
  // +optional
  optional int32 kubeAPIQPS = 55;

  // kubeAPIBurst is the burst to allow while talking with kubernetes apiserver
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact scalability by changing the amount of traffic the Kubelet
  // sends to the API server.
  // Default: 10
  // +optional
  optional int32 kubeAPIBurst = 56;

  // serializeImagePulls when enabled, tells the Kubelet to pull images one
  // at a time. We recommend *not* changing the default value on nodes that
  // run docker daemon with version  < 1.9 or an Aufs storage backend.
  // Issue #10959 has more details.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may impact the performance of image pulls.
  // Default: true
  // +optional
  optional bool serializeImagePulls = 57;

  // Map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available": "300Mi"}.
  // To explicitly disable, pass a 0% or 100% threshold on an arbitrary resource.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may trigger or delay Pod evictions.
  // Default:
  //   memory.available:  "100Mi"
  //   nodefs.available:  "10%"
  //   nodefs.inodesFree: "5%"
  //   imagefs.available: "15%"
  // +optional
  map<string, string> evictionHard = 58;

  // Map of signal names to quantities that defines soft eviction thresholds.
  // For example: {"memory.available": "300Mi"}.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may trigger or delay Pod evictions, and may change the allocatable reported
  // by the node.
  // Default: nil
  // +optional
  map<string, string> evictionSoft = 59;

  // Map of signal names to quantities that defines grace periods for each soft eviction signal.
  // For example: {"memory.available": "30s"}.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may trigger or delay Pod evictions.
  // Default: nil
  // +optional
  map<string, string> evictionSoftGracePeriod = 60;

  // Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // lowering it may decrease the stability of the node when the node is overcommitted.
  // Default: "5m"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration evictionPressureTransitionPeriod = 61;

  // Maximum allowed grace period (in seconds) to use when terminating pods in
  // response to a soft eviction threshold being met. This value effectively caps
  // the Pod's TerminationGracePeriodSeconds value during soft evictions.
  // Note: Due to issue #64530, the behavior has a bug where this value currently just
  // overrides the grace period during soft eviction, which can increase the grace
  // period from what is set on the Pod. This bug will be fixed in a future release.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // lowering it decreases the amount of time Pods will have to gracefully clean
  // up before being killed during a soft eviction.
  // Default: 0
  // +optional
  optional int32 evictionMaxPodGracePeriod = 62;

  // Map of signal names to quantities that defines minimum reclaims, which describe the minimum
  // amount of a given resource the kubelet will reclaim when performing a pod eviction while
  // that resource is under pressure. For example: {"imagefs.available": "2Gi"}
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may change how well eviction can manage resource pressure.
  // Default: nil
  // +optional
  map<string, string> evictionMinimumReclaim = 63;

  // podsPerCore is the maximum number of pods per core. Cannot exceed MaxPods.
  // If 0, this field is ignored.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // changes may cause Pods to fail admission on Kubelet restart, and may change
  // the value reported in Node.Status.Capacity[v1.ResourcePods], thus affecting
  // future scheduling decisions. Increasing this value may also decrease performance,
  // as more Pods can be packed into a single node.
  // Default: 0
  // +optional
  optional int32 podsPerCore = 64;

  // enableControllerAttachDetach enables the Attach/Detach controller to
  // manage attachment/detachment of volumes scheduled to this node, and
  // disables kubelet from executing any attach/detach operations
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // changing which component is responsible for volume management on a live node
  // may result in volumes refusing to detach if the node is not drained prior to
  // the update, and if Pods are scheduled to the node before the
  // volumes.kubernetes.io/controller-managed-attach-detach annotation is updated by the
  // Kubelet. In general, it is safest to leave this value set the same as local config.
  // Default: true
  // +optional
  optional bool enableControllerAttachDetach = 65;

  // protectKernelDefaults, if true, causes the Kubelet to error if kernel
  // flags are not as it expects. Otherwise the Kubelet will attempt to modify
  // kernel flags to match its expectation.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // enabling it may cause the Kubelet to crash-loop if the Kernel is not configured as
  // Kubelet expects.
  // Default: false
  // +optional
  optional bool protectKernelDefaults = 66;

  // If true, Kubelet ensures a set of iptables rules are present on host.
  // These rules will serve as utility rules for various components, e.g. KubeProxy.
  // The rules will be created based on IPTablesMasqueradeBit and IPTablesDropBit.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // disabling it will prevent the Kubelet from healing locally misconfigured iptables rules.
  // Default: true
  // +optional
  optional bool makeIPTablesUtilChains = 67;

  // iptablesMasqueradeBit is the bit of the iptables fwmark space to mark for SNAT
  // Values must be within the range [0, 31]. Must be different from other mark bits.
  // Warning: Please match the value of the corresponding parameter in kube-proxy.
  // TODO: clean up IPTablesMasqueradeBit in kube-proxy
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it needs to be coordinated with other components, like kube-proxy, and the update
  // will only be effective if MakeIPTablesUtilChains is enabled.
  // Default: 14
  // +optional
  optional int32 iptablesMasqueradeBit = 68;

  // iptablesDropBit is the bit of the iptables fwmark space to mark for dropping packets.
  // Values must be within the range [0, 31]. Must be different from other mark bits.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it needs to be coordinated with other components, like kube-proxy, and the update
  // will only be effective if MakeIPTablesUtilChains is enabled.
  // Default: 15
  // +optional
  optional int32 iptablesDropBit = 69;

  // featureGates is a map of feature names to bools that enable or disable alpha/experimental
  // features. This field modifies piecemeal the built-in default values from
  // "k8s.io/kubernetes/pkg/features/kube_features.go".
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider the
  // documentation for the features you are enabling or disabling. While we
  // encourage feature developers to make it possible to dynamically enable
  // and disable features, some changes may require node reboots, and some
  // features may require careful coordination to retroactively disable.
  // Default: nil
  // +optional
  map<string, bool> featureGates = 70;

  // failSwapOn tells the Kubelet to fail to start if swap is enabled on the node.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // setting it to true will cause the Kubelet to crash-loop if swap is enabled.
  // Default: true
  // +optional
  optional bool failSwapOn = 71;

  // A quantity defines the maximum size of the container log file before it is rotated.
  // For example: "5Mi" or "256Ki".
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may trigger log rotation.
  // Default: "10Mi"
  // +optional
  optional string containerLogMaxSize = 72;

  // Maximum number of container log files that can be present for a container.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // lowering it may cause log files to be deleted.
  // Default: 5
  // +optional
  optional int32 containerLogMaxFiles = 73;

  // ConfigMapAndSecretChangeDetectionStrategy is a mode in which
  // config map and secret managers are running.
  // Default: "Watching"
  // +optional
  optional string configMapAndSecretChangeDetectionStrategy = 74;

  // systemReserved is a set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G)
  // pairs that describe resources reserved for non-kubernetes components.
  // Currently only cpu and memory are supported.
  // See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may not be possible to increase the reserved resources, because this
  // requires resizing cgroups. Always look for a NodeAllocatableEnforced event
  // after updating this field to ensure that the update was successful.
  // Default: nil
  // +optional
  map<string, string> systemReserved = 75;

  // A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs
  // that describe resources reserved for kubernetes system components.
  // Currently cpu, memory and local storage for root file system are supported.
  // See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // it may not be possible to increase the reserved resources, because this
  // requires resizing cgroups. Always look for a NodeAllocatableEnforced event
  // after updating this field to ensure that the update was successful.
  // Default: nil
  // +optional
  map<string, string> kubeReserved = 76;

  // This flag helps kubelet identify absolute name of top level cgroup used to enforce `SystemReserved` compute resource reservation for OS system daemons.
  // Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: ""
  // +optional
  optional string systemReservedCgroup = 77;

  // This flag helps kubelet identify absolute name of top level cgroup used to enforce `KubeReserved` compute resource reservation for Kubernetes node system daemons.
  // Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
  // Dynamic Kubelet Config (beta): This field should not be updated without a full node
  // reboot. It is safest to keep this value the same as the local config.
  // Default: ""
  // +optional
  optional string kubeReservedCgroup = 78;

  // This flag specifies the various Node Allocatable enforcements that Kubelet needs to perform.
  // This flag accepts a list of options. Acceptable options are `none`, `pods`, `system-reserved` & `kube-reserved`.
  // If `none` is specified, no other options may be specified.
  // Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
  // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
  // removing enforcements may reduce the stability of the node. Alternatively, adding
  // enforcements may reduce the stability of components which were using more than
  // the reserved amount of resources; for example, enforcing kube-reserved may cause
  // Kubelets to OOM if it uses more than the reserved resources, and enforcing system-reserved
  // may cause system daemons to OOM if they use more than the reserved resources.
  // Default: ["pods"]
  // +optional
  repeated string enforceNodeAllocatable = 79;
}

message KubeletWebhookAuthentication {
  // enabled allows bearer token authentication backed by the tokenreviews.authentication.k8s.io API
  // +optional
  optional bool enabled = 1;

  // cacheTTL enables caching of authentication results
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration cacheTTL = 2;
}

message KubeletWebhookAuthorization {
  // cacheAuthorizedTTL is the duration to cache 'authorized' responses from the webhook authorizer.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration cacheAuthorizedTTL = 1;

  // cacheUnauthorizedTTL is the duration to cache 'unauthorized' responses from the webhook authorizer.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration cacheUnauthorizedTTL = 2;
}

message KubeletX509Authentication {
  // clientCAFile is the path to a PEM-encoded certificate bundle. If set, any request presenting a client certificate
  // signed by one of the authorities in the bundle is authenticated with a username corresponding to the CommonName,
  // and groups corresponding to the Organization in the client certificate.
  // +optional
  optional string clientCAFile = 1;
}

